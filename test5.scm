(define true #t)
(define false #f)
(define (tagged-list? exp-m tag)
  (if (pair? exp-m)
    (eq? (car exp-m) tag)
    false))

(define (make-machine ops controller-text)
  (let ((machine (make-new-machine)))
	      ((machine 'install-operations) ops)
	      ((machine 'install-instruction-sequence)
	       (assemble controller-text machine))
	      machine))

(define (make-register name)
  (let ((contents '*unassigned*)
	(traced false)
	)
    (define (display-info value)
    (newline)
    (display name)
    (display " ")
    (display contents)
    (display "=>")
    (display value)
    (newline))
    (define (dispatch message)
      (cond ((eq? message 'get) contents)
	    ((eq? message 'trace-on!) (lambda () (set! traced true) 'trace-on))
	    ((eq? message 'traced) traced)
	    ((eq? message 'trace-off!) (lambda () (set! traced false) 'trace-off))	
	    ((eq? message 'set) (lambda (value) (if traced (display-info value)) (set! contents value)))
	    (else (error "Unknown request -- REGISTER" message))))
    dispatch))

(define (get-contents register) (register 'get))
(define (set-contents! register value) ((register 'set) value))

(define (make-stack)
  (let ((s '())
	(number-pushes 0)
	(max-depth 0)
	(current-depth 0))
    (define (push x)
      (set! s (cons x s))
      (set! number-pushes (+ 1 number-pushes))
      (set! current-depth (+ 1 current-depth))
      (set! max-depth (max current-depth max-depth)))
    (define (pop)
      (if (null? s)
	(error "Empty stack -- POP")
	(let ((top (car s)))
	  (set! s (cdr s))
	  (set! current-depth (- current-depth 1))
	  top)))
    (define (initialize)
      (set! s '())
      (set! number-pushes 0)
      (set! max-depth 0)
      (set! current-depth 0)
      'done)
    (define (print-statistics)
      (newline)
      (display (list 'total-pushes '= number-pushes
		     'maximum-depth '= max-depth)) (newline) )
    (define (dispatch message)
      (cond 
	((eq? message 'push) push)
	((eq? message 'pop) (pop))
	((eq? message 'initialize) (initialize))
	((eq? message 'print-statistics) (print-statistics))
	(else (error "Unknown request -- STACK" message))))
    dispatch))

(define (pop stack)
(stack 'pop))
(define (push stack value)
((stack 'push) value))

(define (make-stack-table-strict)
  (let ((s '()))
    (define (push var value)
      (set! s (cons (cons var value) s)))
    (define (pop var)
      (if (null? s)
	(error "Empty stack -- POP")
	(let ((top (car s)))
	  (if (eq? var (car top))
	    (begin (set! s (cdr s)) (cdr top))
	    (error "VARIABLE NOT SAME -- POP Table-Strict" var (car top))
	    ))))
    (define (initialize)
      (set! s '())
      'done)
    (define (dispatch message)
      (cond 
	((eq? message 'push) push)
	((eq? message 'pop)  pop)
	((eq? message 'initialize) (initialize))
	(else (error "Unknown request -- STACK" message))))
    dispatch))

(define (pop-table-strict stack variable)
((stack 'pop) variable))
(define (push-table-strict stack variable value)
((stack 'push) variable value))

(define (make-stack-table)
  (let ((s '()))
    (define (push var value)
      (let ((pair (assoc var s)))
      (if pair
	(begin (((cdr pair) 'push) value) s)
	(begin (set! s (cons (cons var (make-stack)) s)) (((cdar s) 'push) value) s))))
    (define (pop var)
      (if (null? s)
	(error "Empty stack -- POP")
	(let ((pair (assoc var s)))
	  (if pair ((cdr pair) 'pop)
	    (error "VARIABLE HAS NO STACK POP Table" var)
	    ))))
    (define (initialize)
      (for-each (lambda (pair) (initalize (cdr pair))) s)
      'done)
    (define (dispatch message)
      (cond 
	((eq? message 'push) push)
	((eq? message 'pop)  pop)
	((eq? message 'initialize) (initialize))
	(else (error "Unknown request -- STACK" message))))
    dispatch))

(define (pop-table stack variable)
((stack 'pop) variable))
(define (push-table stack variable value)
((stack 'push) variable value))
(define (initialize stack) (stack 'initialize))

(define (make-new-machine) ;; HERE!!!
  (let ((pc (make-register 'pc))
	(flag (make-register 'flag))
	(stack (make-stack))
	(the-instruction-sequence '())
	(used-instructions '())
	(entry-points '())
	(stacked '())
	(assignments '())
	(instruction-counter 0)
	(instruction-count 0)
	(trace false)
	(labels '())
	(breakpoints '())
	)
    (let ((the-ops (list (list 'initialize-stack (lambda () (stack 'initialize)))))
	  (register-table (list (list 'pc pc) (list 'flag flag))))
      (define (add-used! inst) 
	(set! used-instructions 
	  (add-sorted-set inst 
			  (lambda (element) (position-of element instruction-set)) 
			  used-instructions)) 
	dispatch)
      (define (add-entry! name) (set! entry-points (add-set name entry-points)) dispatch)
      (define (add-stacked! name) (set! stacked (add-set name stacked)) dispatch)
      (define (add-assignment! name inst) (let ((pair (assoc name assignments)))
					    (if pair (set-cdr! pair (add-set inst (cdr pair)))
					      (set! assignments (cons (cons name (list inst)) assignments))) dispatch))
      (define (add-label-trace! name counter) (set! labels (cons (cons counter name) labels)) dispatch)
      (define (allocate-register name)
	(if (assoc name register-table)
	  (error "Multiply defined register: " name)
	  (set! register-table
	    (cons (list name (make-register name))
		  register-table)))
	'register-allocated)
      (define (lookup-register name)
	(let ((val (assoc name register-table)))
	  (if val (cadr val)
	    (error "Unknown register:" name))))
      (define (reset-counter!) (set! instruction-counter 0))

      (define (trace-on!) (set! trace true) 'trace-on)
      (define (trace-off!) (set! trace false) 'trace-off)
      
      (define (set-breakpoint! label n)
	(let ((pair (assoc-cdr label labels)))
	  (if pair
	    (begin (set! breakpoints (add-sorted-set (cons (+ (car pair) n) (cons (cdr pair) n)) (lambda (element) (car element)) breakpoints)) dispatch)
	    (error "Unknown label -- Set-Breakpoint" label))))


      (define (cancel-breakpoint! label n)
	(define (work current)
	  (cond 
	    ((null? current) '())
	    ((and (eq? label (cadar current)) (eq? n (cddar current))) (cdr current))
	    (else  (cons (car current) (work (cdr current))))))
	(set! breakpoints (work breakpoints)) dispatch)

      (define (cancel-all-breakpoints) (set! breakpoints '()) dispatch)
      
      (define (display-line insts)
	(let ((label (assoc (modulo instruction-counter instruction-count) labels)))
	  (if label (begin (display (cdr label)) (newline))))
	(display (list instruction-counter ":" (instruction-text (car insts))))	 (newline))

      (define (execute-debug proceed)
	(set! instruction-counter (+ 1 instruction-counter))
	(let ((insts (get-contents pc)))
	  (if (null? insts)
	    'done
	    (begin
	      (if trace (display-line insts))
	      (if proceed (begin ((instruction-execution-proc (car insts))) (execute-debug false)))
	      (let ((breakpoint (assoc (modulo instruction-counter instruction-count) breakpoints)))
		(if breakpoint (begin (newline) (display (cadr breakpoint)) (display " : ") (display (cddr breakpoint)) (newline))
		 (begin ((instruction-execution-proc (car insts))) (execute-debug false))))))))

      (define (execute-debugless)
	(set! instruction-counter (+ 1 instruction-counter))
	(let ((insts (get-contents pc)))
	  (if (null? insts)
	    'done
	    (begin
	      (if trace (display-line insts))
		 ((instruction-execution-proc (car insts)))
		 (execute-debugless)))))
      
      (define (execute)
	(if (null? breakpoints)
	  (execute-debugless)
	  (execute-debug false)))

      (define (get-trace-setting name type) ((lookup-register name) type))
      (define (dispatch message)
	(cond 
	  ((eq? message 'start)
	   (set-contents! pc the-instruction-sequence)
	   (reset-counter!)
	   (execute))
	  ((eq? message 'proceed) (if (or (null? (get-contents pc)) (eq? (get-contents pc) '*unassigned*)) (error "CANNOT PROCEED WHEN NOT RUN OR TERMINATED") (execute-debug true)))
	  ((eq? message 'install-instruction-sequence) (lambda (seq) (set! the-instruction-sequence seq) (set! instruction-count (length seq))))
	  ((eq? message 'allocate-register) allocate-register)
	  ((eq? message 'get-register) lookup-register)
	  ((eq? message 'install-operations) (lambda (ops) (set! the-ops (append the-ops ops))))
	  ((eq? message 'stack) stack)
	  ((eq? message 'operations) the-ops)
	  ((eq? message 'registers) register-table)
	  ((eq? message 'has-register?) (lambda (name) (if (assoc name register-table) true false)))
	  ((eq? message 'add-used!) add-used!)
	  ((eq? message 'add-entry!) add-entry!)
	  ((eq? message 'add-stacked!) add-stacked!)
	  ((eq? message 'add-assignment!) add-assignment!)
	  ((eq? message 'add-label-trace!) add-label-trace!)
	  ((eq? message 'labels) labels)
	  ((eq? message 'trace-on!) trace-on!)
	  ((eq? message 'trace-off!) trace-off!)
	  ((eq? message 'register-trace-on!) (lambda (name) (get-trace-setting name 'trace-on!)))
	  ((eq? message 'register-trace-off!) (lambda (name) (get-trace-setting name 'trace-off!)))
	  ((eq? message 'assignments) assignments)
	  ((eq? message 'stacked) stacked)
	  ((eq? message 'instruction-counter) instruction-counter)
	  ((eq? message 'entry-points) entry-points)
	  ((eq? message 'breakpoints) breakpoints)
	  ((eq? message 'set-breakpoint!) set-breakpoint!)
	  ((eq? message 'cancel-breakpoint!) cancel-breakpoint!)
	  ((eq? message 'cancel-all-breakpoints) cancel-all-breakpoints)
	  ((eq? message 'used-instructions) used-instructions)
	  ((eq? message 'instruction-sequence) the-instruction-sequence)
	  (else (error "Unknown request -- MACHINE" message))))
dispatch)))

(define (assoc-cdr element table)
  (cond 
    ((null? table) false)
    ((eq? element (cdar table)) (car table))
    (else (assoc-cdr element (cdr table)))))

(define (start machine) (machine 'start))
(define (proceed machine) (machine 'proceed))
(define (get-register-contents machine register-name)
  (get-contents (get-register machine register-name)))
(define (set-register-contents! machine register-name value)
  (set-contents! (get-register machine register-name) value)
  'done)
(define (get-register machine reg-name)
  ((machine 'get-register) reg-name))

(define (assemble controller-text machine)
  (extract-labels controller-text
		  (lambda (insts labels)
		    (update-insts! insts labels machine)
		    insts)
		  machine 1
		  ))

(define (update-insts! insts labels machine)
  (let ((pc (get-register machine 'pc))
	(flag (get-register machine 'flag))
	(stack (machine 'stack))
	(ops (machine 'operations)))
    (for-each
      (lambda (inst)
	(set-instruction-execution-proc!
	  inst
	  (make-execution-procedure (instruction-text inst) labels machine pc flag stack ops)))
      insts)))


(define (extract-labels text receive machine counter)
  (if (null? text)
    (receive '() '())
    (extract-labels (cdr text)
		    (lambda (insts labels)
		      (let ((next-inst (car text)))
			(if (symbol? next-inst)
			  (begin (add-label-trace! machine next-inst counter) (receive insts (update-labels-if-possible (make-label-entry next-inst insts) labels)))
			  (receive (cons (make-instruction next-inst)
					 insts)
				   labels)))) machine (+ 1 counter) )))

(define instruction-set '(assign branch goto perform restore save test))

(define (update-labels-if-possible label-entry labels)
  (if (assoc (car label-entry) labels)
    (error "ALREADY DEFINED LABEL -- ASSEMBLE" (car label-entry))
    (cons label-entry labels)))

(define (make-instruction text)
  (cons text '()))
(define (instruction-text inst)
  (car inst))
(define (instruction-execution-proc inst)
  (cdr inst))
(define (set-instruction-execution-proc! inst proc)
  (set-cdr! inst proc))

(define (make-label-entry label-name insts)
(cons label-name insts))

(define (lookup-label labels label-name)
  (let ((val (assoc label-name labels)))
    (if val
      (cdr val)
      (error "Undefined label -- ASSEMBLE" label-name))))

(define (make-execution-procedure inst labels machine pc flag stack ops)
  (if (memq (car inst) instruction-set)
    (add-used-instruction! machine (car inst)))
  (cond 
    ((eq? (car inst) 'assign)
     (make-assign inst machine labels ops pc))
    ((eq? (car inst) 'test)
     (make-test inst machine labels ops flag pc))
    ((eq? (car inst) 'branch)
     (make-branch inst machine labels flag pc))
    ((eq? (car inst) 'goto)
     (make-goto inst machine labels pc))
    ((eq? (car inst) 'save)
     (make-save inst machine stack pc))
    ((eq? (car inst) 'restore)
     (make-restore inst machine stack pc))
    ((eq? (car inst) 'perform)
     (make-perform inst machine labels ops pc))
    (else (error "Unknown instruction type -- ASSEMBLE" inst))))

(define (add-used-instruction! machine instruction)
  ((machine 'add-used!) instruction))
(define (add-entry-point! machine name)
  ((machine 'add-entry!) name))
(define (add-stacked! machine name)
  ((machine 'add-stacked!) name))
(define (add-assignment! machine name exp)
  ((machine 'add-assignment!) name exp))
(define (add-register! machine name)
  (if (not ((machine 'has-register?) name)) ((machine 'allocate-register) name)))
(define (add-label-trace! machine label counter)
  ((machine 'add-label-trace!) label counter))


(define (add-set element set) (if (memq element set) set (cons element set)))
(define (add-sorted-set element pred set) 
  (cond 
    ((null? set) (list element))
    ((< (pred element) (pred (car set))) (cons element set))
    ((= (pred element) (pred (car set))) (if (equal? element (car set)) set (cons element set)))
    ((> (pred element) (pred (car set))) (cons (car set) (add-sorted-set element pred (cdr set))))))

(define (make-assign inst machine labels operations pc)
  (let ((name (assign-reg-name inst)))
        (add-register! machine name)
  (let 
    ((target (get-register machine name))
     (value-exp (assign-value-exp inst)))
    (add-assignment! machine name value-exp)
    (let ((value-proc
	    (if (operation-exp? value-exp)
	      (make-operation-exp value-exp machine labels operations)
	      (make-primitive-exp (car value-exp) machine labels))))
      (lambda () ; execution procedure for assign
	(set-contents! target (value-proc))
	(advance-pc pc))))))

(define (assign-reg-name assign-instruction) (cadr assign-instruction))
(define (assign-value-exp assign-instruction) (cddr assign-instruction))

(define (advance-pc pc) (set-contents! pc (cdr (get-contents pc))))

(define (make-test inst machine labels operations flag pc)
  (let ((condition (test-condition inst)))
    (if (operation-exp? condition)
      (let ((condition-proc (make-operation-exp condition machine labels operations)))
	(lambda ()
	  (set-contents! flag (condition-proc))
	  (advance-pc pc)))
      (error "Bad TEST instruction -- ASSEMBLE" inst))))
(define (test-condition test-instruction)
  (cdr test-instruction))

(define (make-branch inst machine labels flag pc)
  (let ((dest (branch-dest inst)))
    (if (label-exp? dest)
      (let ((insts (lookup-label labels (label-exp-label dest))))
	(lambda ()
	  (if (get-contents flag)
	    (set-contents! pc insts)
	    (advance-pc pc))))
      (error "Bad BRANCH instruction -- ASSEMBLE" inst))))

(define (branch-dest branch-instruction)
(cadr branch-instruction))

(define (make-goto inst machine labels pc)
  (let ((dest (goto-dest inst)))
    (cond 
      ((label-exp? dest)
       (let ((insts (lookup-label labels (label-exp-label dest))))
	 (lambda () (set-contents! pc insts))))
      ((register-exp? dest)
       (let ((name (register-exp-reg dest)))
	 (add-entry-point! machine name)
       (let ((reg (get-register machine name)))
	 (lambda ()
	   (set-contents! pc (get-contents reg))))))
      (else (error "Bad GOTO instruction -- ASSEMBLE" inst)))))

(define (goto-dest goto-instruction)
(cadr goto-instruction))

(define (make-save inst machine stack pc)
  (let ((name (stack-inst-reg-name inst)))
    (add-stacked! machine name)
  (let ((reg (get-register machine name)))
    (lambda ()
      (push stack (get-contents reg))
      (advance-pc pc)))))

(define (make-restore inst machine stack pc)
  (let ((name (stack-inst-reg-name inst)))
    (add-stacked! machine name)
  (let ((reg (get-register machine name)))
    (lambda ()
      (set-contents! reg (pop stack))
      (advance-pc pc)))))
(define (stack-inst-reg-name stack-instruction)
(cadr stack-instruction))

(define (make-save-table inst machine stack pc)
  (let ((name (stack-inst-reg-name inst)))
  (let ((reg (get-register machine name)))
    (lambda ()
      (push-table-strict stack name (get-contents reg))
      (advance-pc pc)))))

(define (make-restore-table inst machine stack pc)
  (let ((name (stack-inst-reg-name inst)))
  (let ((reg (get-register machine name)))
    (lambda ()
      (set-contents! reg (pop-table-strict stack name inst))
      (advance-pc pc)))))
(define (stack-inst-reg-name stack-instruction)
(cadr stack-instruction))

(define (make-perform inst machine labels operations pc)
  (let ((action (perform-action inst)))
    (if (operation-exp? action)
      (let ((action-proc (make-operation-exp action machine labels operations)))
	(lambda ()
	  (action-proc)
	  (advance-pc pc)))
      (error "Bad PERFORM instruction -- ASSEMBLE" inst))))
(define (perform-action inst) (cdr inst))

(define (make-primitive-exp exp machine labels)
  (cond 
    ((constant-exp? exp) (let ((c (constant-exp-value exp))) (lambda () c)))
    ((label-exp? exp) (let ((insts (lookup-label labels (label-exp-label exp))))
			(lambda () insts)))
    ((register-exp? exp) (add-register! machine (register-exp-reg exp)) (let ((r (get-register machine (register-exp-reg exp))))
			   (lambda () (get-contents r))))
    (else (error "Unknown expression type -- ASSEMBLE" exp))))

(define (make-primitive-exp-bootstrapped exp machine labels)
  (cond 
    ((constant-exp? exp) (let ((c (constant-exp-value exp))) (lambda () c)))
    ((label-exp? exp) (let ((insts (lookup-label labels (label-exp-label exp))))
			(lambda () insts)))
    ((register-exp? exp) (let ((r (get-register machine (register-exp-reg exp))))
			   (lambda () (get-contents r))))
    (else (error "Unknown expression type -- ASSEMBLE" exp))))

(define (register-exp? exp) (tagged-list? exp 'reg))
(define (register-exp-reg exp) (cadr exp))
(define (constant-exp? exp) (tagged-list? exp 'const))
(define (constant-exp-value exp) (cadr exp))
(define (label-exp? exp) (tagged-list? exp 'label))
(define (label-exp-label exp) (cadr exp))

(define (make-operation-exp exp machine labels operations)
  (let ((op (lookup-prim (operation-exp-op exp) operations))
	(aprocs (if (any? label-exp? (operation-exp-operands exp)) (error "LABEL IN OPERATION -- ASSEMBLE" exp) 
		  (map (lambda (e) (make-primitive-exp e machine labels))
		     (operation-exp-operands exp)))))
    (lambda () (apply op (map (lambda (p) (p)) aprocs)))))

(define (operation-exp? exp) (and (pair? exp) (tagged-list? (car exp) 'op)))
(define (operation-exp-op operation-exp) (cadr (car operation-exp)))
(define (operation-exp-operands operation-exp) (cdr operation-exp))

(define (lookup-prim symbol operations)
  (let ((val (assoc symbol operations)))
    (if val
      (cadr val)
      (error "Unknown operation -- ASSEMBLE" symbol))))

(define (any? pred l)
  (if (null? l) false
    (or (pred (car l)) (any? pred (cdr l)))))

(define (gcd-machine)
  (make-machine	(list (list 'rem remainder) (list '= =))
		'( (assign a (const 16932))
		   (assign b (const 1002))
		  test-b (test (op =) (reg b) (const 0))
			 (branch (label gcd-done))
			 (assign t (op rem) (reg a) (reg b))
			 (assign a (reg b))
			 (assign b (reg t))
			 (goto (label test-b))
			 gcd-done)))

(define (fact-machine)
  (make-machine (list (list '= =) (list '* *) (list '- -) (list 'read read) (list 'print (lambda (x) (display x) (newline))))
		'(controller
		   (assign n (op read))
		   (test (op =) (reg n) (const 0))
		   (branch (label end))
		   (perform (op initialize-stack))
		   (assign continue (label end-fact))

		   start-fact
		   (test (op =) (reg n) (const 1))
		   (branch (label base))
		   (save n)
		   (assign n (op -) (reg n) (const 1))
		   (save continue)
		   (assign continue (label after-base))
		   (goto (label start-fact))

		   after-base
		   (restore continue)
		   (restore n)
		   (assign val (op *) (reg n) (reg val))
		   (goto (reg continue))

		   base
		   (assign val (const 1))
		   (goto (reg continue))
		   	
		   end-fact
		   (perform (op print) (reg val))
		   (goto (label controller))
		   end
		   
		   )))

(define (count-leaves-machine)
  (make-machine (list (list 'null? null?) (list 'pair? pair?) (list '+ +))
		'(controller
		   (assign continue (label cond-test))
		   cond-test
		   (test (op null?) (reg tree))
		   (branch (label is-null))
		   (test (op pair?) (reg tree))
		   (branch (label is-pair))
		   (assign val 1)
		   (goto (reg continue))

		   is-pair
		   (save tree)
		   (assign tree (op car) (reg tree))
		   (save continue)
		   (assign continue (label counted-car))
		   (goto (label cond-test))
		   
		   counted-car
		   (restore continue)
		   (restore tree)
		   (save tree)
		   (assign tree (op cdr) (reg tree))
		   (save val)
		   (save continue

		   counted-cdr
		   (restore continue)
		   (restore tree)
		   (assign val (op +) (reg tree) (reg val))
		   (restore tree)
		   (goto (reg continue))

		   is-null
		   (assign val (const 0))
		   (goto (reg continue))

(define (position-of element l)
  (define (work current index)
    (cond 
      ((null? current) false)
      ((eq? (car current) element) index)
      (else (work (cdr current) (+ 1 index)))))
  (work l 0))

; (lambda (x y) (< (position-of x instruction-set) (position-of y instruction-set)))
